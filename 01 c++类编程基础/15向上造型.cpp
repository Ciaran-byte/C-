
#include<iostream>
using namespace std;
class A   //01我们构造了一个A类和B类，其中B是A的子类，那就意味着B拥有A的所有数据和结构
{
protected:
	int i;
public:
	A():i(10) {}
	void print()
	{
		cout << "this is a" << endl;
		cout << i<<endl;
	}
};

class B :public A
{
private:
	int j;
public:
	B() :j(10) {}
	void print()
	{
		cout << "this is b" << endl;
		cout << i << endl;
		cout << j<<endl;
	}
};

int main()
{
	//这一部分代码，我们通过指针的方法，探索类中的数据存放结构是什么，并且通过指针修改内部的私有变量。
	
	A a;
	B b;
	a.print();
	b.print();
	int* pa = (int*)&a;  //我们把实例对象a和b变成int类型的指针，可以看看会发生什么事情
	int* pb = (int*)&b;

	*pa = 20;  //我们利用外部的指针，可以修改a和b的数据，因为a有两个变量，*pa实际上就是指向了i，而b有两个变量，*pb实际指向了i;
	*pb = 20;
	a.print();
	b.print();
	  
	pb++;        //通过对b指针移位，可以访问它的j变量，说明b是a的子类，那就意味着数据结构的存放方式是，先把a的数据存储结构复制一份，再加入b的特有的数据存储结构。
	*pb = 30;
	b.print();


	//这一部分代码，我们来测试怎么把子类当做父类使用，也就是向上造型
	
	A* m = &b; //    b是类B的实例，m是A类的指针。这就是把子类的指针当做父类使用，但是b中特有的东西会丢失，在本程序中，A和B都有print函数，当我们把b当做A类使用的时候，
	           //b中特有的函数print和变量j会丢失，这个地方再运行print，就是A类中的print了，这种父类指针指向子类，把子类当做父类使用的方法叫做upcast向上造型
	           //向上造型是安全的，因为子类具有父类的所有东西。但是反过来，如果把父类当做子类使用，叫做downcast向下造型，就是不安全的了，因为子类中有些东西父类不一定有
	           //举个例子就是，学生是人的子类，因此所有学生都可以作为人来使用，但是人不一定具有学生的特性。
	m->print();

	return 0;
}





//注解1：向上造型的意思就是，子类可以被当做父类对象使用。因为一个类的数据结构，实际上里面只存放的变量，因此，子类有父类的所有变量，所以子类可以被当做父类使用
//但是子类被当做父类使用的时候，子类特有的变量和函数就不能被使用了。
//注解2：我们做一部分程序，来测试类实际的数据结构。
