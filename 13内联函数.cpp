
//程序功能：内联函数的使用方法,这个文件main前面有两种写法，一种正确的，一种错误的，运行时取消全部注解，再取消正确和错误写法的/**/符号即可正常测试
     //正确写法是把函数体全部写在头文件中或者写在main文件里，具体解释看注解5
#include<iostream>
using namespace std;

 inline void add(int a,int b)
{
  cout<<a+b;
}    
 /*#include "13inline.h"  //错误写法：这个头文件里面可以看到里面只有内联函数的函数头，却没有写函数定义，这是不能正确运行的*/
int main()
{
	int a = 1, b = 2;
	add(a, b);

	return 0;
}

//   注解1：内联函数是以关键词inline定义的。
//   注解2：内联函数的作用：一般来说，函数在使用的时候会有这样的过程，在内存中申请一块空间，把数据写入寄存器，在寄存器处理数据，把结果写入栈堆，返回数据，释放占用空间
//一般函数能够简化程序，使得整个程序看起来更加简介，但是是以多次调用和释放为代价的。如果这个函数体积比较小，而且又重复多次调用，必定会占用很大的空间。
//而内联函数与宏定义有类似的地方，写了函数的地方，实质上是把函数体里面的内容复制到了程序中，比如在本程序中add(a,b)，编译后变成cout<<a+b；这样的话，函数体就不需要
//调用了，直接就可以进行数据的运行，提升了速度。但是缺点是最后产生的编译文件、连接文件、运行文件体积都会增加，因为每次使用函数，都要复制一次这些代码。这是一种牺牲
//空间换取时间的做法。内联函数与宏定义的函数是有区别的，区别在于，内联函数能够检测变量数据类型是否合格，而宏定义不能做这个事情。
//    注解3：什么时候可以使用内联函数：（1）当函数代码量很小，一般小于20行（2）多次被调用，比如在循环中
//    注解4:什么时候不能使用内联函数：（1）函数体代码量比较大，比如大于20行（3）函数是一个递归函数，递归函数必然要使用栈堆空间，内联函数没有意义
//    注解5：怎么使用内联函数：我们可以看到，一般函数都会有两个文件，一个头文件和一个函数体文件，这样就可以在main函数里面使用这些函数了。而使用这种方法写了程序13是
//不能正确运行的。原因在于：当开始预编译main文件的时候，会先把h文件拷贝进来，告诉编译器，add函数是一个内联函数，而main就开始找这个函数的函数体，想把他复制进
//主程序，但是他找不到这个主程序的定义，于是就只能在内存里引发一个函数调用指令，去其他地方寻找这个内联函数，这是inline.h和内联函数.cpp这两个文件做的事情
//而另外一方面，inline.cpp里面存放了内联函数的函数体定义，在做预编译的时候，编译器发现这是个内联函数，得出一个结论，他是直接用来翻译的，不需要写入编译出来的文件中
//所以就出现了，main函数内部没有add函数的定义，他不得不去外面的文件找，而有add函数体定义的inline.cpp文件又没有产生这个定义，所以就会产生main中内联函数无定义的错误
//因此，我们就得到一个结论，内联函数必须把全部的定义都放在头文件或者直接写在main函数文件中，否则无法被找到。
//    注解6：内联函数在书写的时候，inline即可以写在函数头前面，也可以写在函数定义里面，但是建议函数头和函数定义前面都要加inline关键词，方便人们阅读。
//    注解7：建议体积小并且多次运行的函数，都写成内联函数，以提高程序的运算速度。