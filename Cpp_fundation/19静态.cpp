
#include<iostream>
using namespace std;

class A
{
public:
	static int i;
	
	static void f()
	{
		cout << i;
		
	}
	A() {  }
};

int A::i;//给静态变量创建了一个容器

int main()
{
	A a;
	a.i = 10;
	A b;
	cout << b.i << endl;
	cout << A::i;//静态变量可以脱离实例生存
	A::f();//静态函数可以直接调用，脱离实例生存
	return 0;
}

//      注解1：对于static的变量来说，一般包含有两层含义：(1)隐藏性，这就意味着，在这个cpp文件里面定义的变量，其他cpp文件不能调用，这是跟全局变量很大的一个区别
//假设有一个全局变量 int i;，那么如果再另外一个cpp文件里面有extern int i；那么另外一个cpp文件就能够找到这个全局变量，并且使用它。而如果这个变量被static修饰了，那么其他
//文件就找不到这个变量了（2）永久性。永久性意味着static的变量具有全局变量的特性，在main函数运行之前被定义好，只能发生一次初始化，并且全局有效。

//      注解2：静态对象的变量：如果一个类的变量是静态的，那就意味着这个类的所有对象都能够使用这个变量，并且这个变量值是固定的。（1）但是我们要注意一个问题就是，如果这个变量
//能够脱离具体对象存在，必须现在程序里面给他一个存放的位置，让他能够生存。所以，程序前面会有一句话 int A::i 这样之后，静态变量i才能够在类A里面存在。或者从另外一个角度
//来考虑，类里面全都是声明，而不是定义，就相当于写了一句 extern int i；只能说明程序里面有这个变量i，但是他具体定义在什么地方，并不知道，我们就需要告诉编译器静态变量的定义位置
//（2）我们要注意的第二个问题是，静态变量初始化一般在类外面进行，如果一定在类内部进行的话，一定不能使用初始化列表的方法，因为这个变量只能初始化一次，使用初始化列表
//逻辑上就是每个实例被创建的时候，都会被初始化因此构造函数如果要给静态变量赋予初值的话，要写 A（）{ i = 0}； 而不能写A:i(0){}。二者意义不同，前者是赋值，后者是初始化
//（3）既然静态变量可以脱离实例存在，那么使用A::i这种方式也是可以直接访问变量的。不过要注意，i必须的public的，如果是private的，是不能访问的。
//（4）关于int A::i；这句话，再做一点说明，这个定义前面是不能加static的，因为从c语言角度考虑，static意味着i不能被其他cpp文件访问了，但是类中的变量应该要被其他cpp文件访问
//所以，这么定义的话，编译会无法通过，违背了类的本来的设计目的

//      注解3：静态对象的函数（1）静态对象的函数和静态对象的变量有相似的性质，都可以脱离实例生存，因此可以通过A::f()的方式进行访问。但是注意，通过这个方式访问静态函数
//，静态函数使用的所有变量也必须的静态的，如果变量不能脱离实例存在，那么函数是不可能调用这些变量的。因此静态函数内部，只能出现静态的变量
//（2）静态对象的函数是没有隐藏参数this的，因为this依赖于具体的实例，静态函数能够脱离实例，为了不产生冲突，静态函数没有隐藏参数this

 //     注解4：静态的使用情景：类的每个实例都需要有一个固定不变的值（比如银行固定利率），而且希望改变的时候能够把所有实例的这个值全都改变，这样就可以使用静态特性
