#include<iostream>
#include<cstring>
using namespace std;

  int my_count = 0;
class A
{
public:
	A() 
	{
		my_count ++;
		cout <<"构造!my_count= "<< my_count << endl;
	}
	~A()
	{
		my_count--;
		cout << "析构!my_count= " << my_count << endl;
	}
};

A f(A a)   //配合测试代码2的函数
{
	return a;
}

class B  //配合测试代码4的类
{
public:
	B()
	{
		my_count++;
		cout << "构造!my_count= " << my_count << endl;
	}
	B(const B& b)  //拷贝构造函数
	{
		my_count++;
		cout << "构造!my_count= " << my_count << endl;
	}
	//错误的拷贝构造函数，这样的结果造成了没有停止条件的递归。每次新建一个B就等待接收一个变量，而要接收的那个变量又需要拷贝构造函数去创建生成，于是永远没有停止条件
	/*B( B b)  
	{
		my_count++;
		cout << "构造!my_count= " << my_count << endl;
	}*/

	~B()
	{
		my_count--;
		cout << "析构!my_count= " << my_count << endl;
	}
};


class Test1 //配合测试代码5的使用
{
private:
	int* p;
public:
	Test1(int x)
	{
		this->p = new int(x);
		cout << "对象被创建" << endl;
	}
	
	~Test1()
	{
		if (p != NULL)
		{
			delete p;
		}
		cout << "对象被释放" << endl;
		
	}
	
};
class Test2 //配合测试代码6的使用-深拷贝
{
private:
	int* p;
public:
	Test2(int x)
	{
		this->p = new int(x);
		cout << "对象被创建" << endl;
	}
	Test2(const Test2& t)  //拷贝构造函数
		{
		cout << "对象被创建" << endl;
		this->p = new int(*(t.p));
		}
	~Test2()
	{
		if (p != NULL)
		{
			delete p;
		}
		cout << "对象被释放" << endl;

	}

};

int main()
{
	//实例代码1：配合注解1，我们可以看到输出结果，定义了一个实例a，count分别+1和-1了一次
	{
		A a;
	}
	cout << endl;

	//实例代码2：配合注解2，通过其他方式调用类A，看看构造和析构情况
	{A a1;
	A a2 = f(a1);
	}
	cout << endl;
	//从输出结果看，我们发现函数的构造函数只被调用了一次，而析构函数调用了3次，这就说明，函数被调用的时候f(A a)和A a2 = f(A a)这两条语句，均没有触发类别A的构造函数
	//但是这并不符合逻辑，因为但凡有析构函数，必然应该有与之对应的构造函数。我们通过代码示例3继续探究这一个问题


	//代码示例3：两种赋值方法配合注解3
	{
		my_count = 0;
		A a2;
		A a3(a2);
		int i(2);  //c++赋值里面（）和=是等价的
		cout << i << endl;
	}
	cout << endl;
	//代码示例4：配合注解4，说明拷贝构造函数怎么用
	{
		my_count = 0;
		B b1;
		B b2 = b1;
		
	}
	cout << endl;


	////代码示例5:这段代码运行会出错的
	//Test1 a(10);
	////会调用默认的拷贝构造函数
	//Test1 b = a;
	
	//测试代码6
	Test2 a(10);
	Test2 b = a;

	return 0;
}


//   注解1：这一部分，我们来讨论一下，当我们把一个类进行复制的时候，发生了什么事情。首先我们定义一个类A，并且通过类A能够用来查看一个函数构造和析构的时候发生了什么
//我们定义了一个全局变量count，当构造函数调用的时候count+1，析构的时候count-1。
//   注解2：如果我们用其他方法使用类A，看看构造函数和析构函数到底运行了多少次
//    注解3：想要知道实例代码2发生了什么，我们必须知道的一个事情是，A a2 = a1这句话，到底发生了什么。对于c++而言，其实赋值可以使用=和（）他们是等价的，可以看实例
//代码3，这就说明，A a3 = a2与A a3(a2)实际上是等价的。看到这个形状，我们就有了点头绪，因为这是构造函数的写法，而默认构造函数是不带参数的。说明
//c++的类里面，必然隐藏了一种默认构造函数，能够接受同类的参数。这个构造函数，就叫做默认的拷贝构造，因此当我们令A a3 = a2的时候，并没有调用默认的构造函数
//而是去调用了隐藏的拷贝构造函数。
//   注解4：拷贝构造函数写法。我们定义了与类A类似的B类，可以看到B类中增加了一个拷贝构造函数带有const B& b的参数，这样的话，我们再写a3 = a2之类的语句时，类就不会调用
//默认的拷贝函数了，而是使用我们写的拷贝构造函数。从测试代码4中，我们就可以发现构造函数的调用和析构守恒了。最终变成了0。这里需要解释一下，为什么传递变量使用
//const B&b。 这与源文件17有关，就是常量引用，这种方法传递类，能够节约内存开销，并且能够防止在函数内部修改变量。同时类B中也给出了一种错误的拷贝构造的写法，这种写法会噪声
//无穷递归没有停止点。

//  注解5：同时，如果我们不想让我们的类能够被拷贝，可以在类里面定义一个私有的拷贝构造函数，这样A a = a1就是非法的了。
//private A(const A& a){};
//  注解6：深拷贝和浅拷贝。这里，我们还要说明的一个问题就是，A a = a1这种写法，如果a里面有指针变量会发生什么事情。
//这里我们就以测试代码5为例进行说明。测试代码5被注释了，如果使用的话，是会报错的。因为他是一种浅拷贝，而且里面含有指针。当第一次初始化的时候，我们传递进去了一个
//int类型的变量，并且用它生成了新的变量，指针指向这个变量，当复制发生的时候，因为我们没有定义拷贝构造，因此会调用默认的构造函数，会使得定义的两个类的实例指向
//了同一块内存地址，当析构函数释放空间的时候，会发现第一个函数析构的时候，释放掉了那个指针的内存，当第二个对象析构的时候，又想去释放那个内存，但是那个内存以及没有了
//就会发生内存冲突的问题而失败，这种情况下，我们应该使用深拷贝来解决这个问题。见测试代码6
//  注解6：测试代码6就是一种深拷贝的写法，函数体指针指向了新的内存地址，这样析构函数就能正常运行了

//  注解7：标准类构造要求，通过前面的例子，到这里，我们对类的构造提个要求，那就是凡是构造一个类，都要满足三个条件
//  (1)必须要写默认的构造函数，而且构造函数通过初始化列表的方法进行初始化（2）必须具有虚拟的析构函数，以满足多态的需求，子类可以扩增函数(3)必须要写拷贝构造函数，满足深拷贝的要求。
