#include<iostream>
using namespace std;

class A
{
private:
	int i;
public:
	A(int ii) :i(ii) {}
	const int operator +(const A& a) //配合注解5和测试代码1
	{
		return this->i + a.i;
	}
	friend const int operator-(const A& a, const A& b);//配合测试代码3和注解7
};

const int operator -(const A& a, const A& b)//配合测试代码3和注解7
{
	return a.i - b.i;
}
int main()
{
	//测试代码1：配合注解5,说明类中的运算符重载
	A a(5), b(10);
	cout << a + b;  //根据注解5，我们知道这句话实际上等价于a.operator+(b)
	
	//测试代码2：配合注解6，说明3+a和a+3对于类中运算符重载的区别
	cout << endl;
	cout << a + 3<<endl;   //语句1：正常运行
 	//cout << 3 + a;//语句2：不能正常运行

	//测试代码3：配合注解7，说明全局的运算符重载的用法
	A a1(5), a2(3);
	cout << endl;
	cout << a1 - a2 << endl;

	//测试代码4：配合注解8，说明全局的运算符重载的用法
	
	cout << endl;
	cout << 5 - a2 << endl;
	cout << a1 - 3 << endl;

	//测试代码5：配合注解9，相当于正常的对象初始化，跟运算符的重载无关
	A c = 5 - 6;

	return 0;
}














//   注解1：什么是运算符重载。运算符重载就是相当于可以重新定义加减乘除等各种运算符，其应用场景在于，比如对于类的相加，可以直接把运算符加号重新定义，让他能够直接
//把实例对象中的成员变量进行加法，可以使得程序看起来更加的简洁。

//   注解2：运算符重载的限制：（1）只有存在的运算符才能够被重载（2）重载不能修改操作数（3）优先级不可以更改


//   注解3：重载的实质其实就相当于是一种函数，通过关键词operator进行重新定义

//   注解4：重载分类和使用。运算符重载可以分别在类中定义，也可以定义在全局



//   注解5：定义在类中的运算符重载。 定义在类中的重载比如 有两个实例对象A a b; 如果+运算符在类中被重载，实际上a+b等价为a.operator+(b)。
//定义在类中的二元运算符要求输入的参数变量会少一个，因为传递的参数具有隐藏参数this,看测试代码1了解类中运算符重载的具体用法。在类A中我们定义了一个+的重载
//同时注意一下重载运算符定义的时候，传入参数应该是 const T&类型的，返回值也应该是const类型的，这是个规则。
//   注解6：测试代码2中有两条看似不符合逻辑的代码，但是语句1能运行，语句2不能运行，为什么呢？因为语句1 a+3我们可以翻译为a.operator+(3)，而类A恰好有一个
//默认构造函数A(int ii)：i(ii)，当3被读入的时候，系统会构建一个匿名的类A，并且把3当做初始化值送入匿名对象，所以能够实现，如果类A没有这个构造函数，就不能运行了
//而3+a是不能正常运行的，因为3没有this这个类，他就是一个整型，不能调用类的重载运算符函数，所以系统不能正常运行这条语句



//  注解7：定义在全局的运算符重载。我们在系统里面定义了全局的运算符-号，用来做类的减法。我们可以看到，定义在全局的变量因为没有默认的this参数，所以二元运算符就要求
//写入两个输入变量，而定义在类中的就只要求一个变量。因为这个函数要去操作类中的私有变量，所以我们必须在A中通过friend的方法赋予operator-访问私有变量的权限
//因此全局的运算符重载，应该注意（1）几元运算符就要几个变量（2）类中应该通过friend方法赋予全局运算符重载函数访问私有变量的权限
//  注解8：跟注解6一样，我们也来研究一下全局条件下的 5-a2和a1-3会怎么样，参考测试代码4，从代码运行结果来看，这两个都是可以运行的。因为全局的运算符重载
//失去了this的限制，前后两个int类型都可以当做参数传递如类A的默认构造函数，所以不会有问题的
//  注解9：那么测试代码5这种写法是否会有问题呢。答案是不会，因为首先5-3调用的是默认的减法，会生成一个int，而int会作为参数，传入默认的构造函数，正常的定义对象c

// 注解10：这里也说明一下什么时候用全局的运算符重载，什么时候用类的运算符重载
//（1）单目运算符建议使用类重载
//（2）双目运算符建议使用全局重载，否则3+a这种东西不能运行
//（3）= （） [] ->这些运算符必须使用类的运算符重载
